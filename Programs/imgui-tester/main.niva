type WordPair original: String translation: String


// app state
mut inGame = false
mut isCompleted = false
shouldShuffle = ImBoolean value: false

mut filePath = ImString value: ""
mut statusMsg = ""
mut pendingPath = ""

mut pairs = List(WordPair) val: {}
mut allTranslations::List(String) = {}
mut queue = List(WordPair) val: {}, toMut
mut pendingPairs = List(WordPair) val: {}
mut recentPaths = List(String) val: {}, toMut
recentFile = File path: "recent_paths.txt"

mut initialTotal = 0
mut currentIdx = 0
mut wordsDone = 0

mut totalCorrect = 0
mut totalErrors = 0
mut hasErrorInCurrentWord = false

mut options::List::String = {}
mut optionsForWordDone = -1
mut disabledOptionIdx::List::Int = {}

mut currentPair = WordPair original: "" translation: ""
mut hasCurrentPair = false

// helpers
recentFile exists
  ifTrue:  [recentPaths <- recentFile readLines toMutableList]
  ifFalse: [
    recentFile writeText: ""
    recentPaths <- {}
  ]

writeRecent = [
  recentPaths isEmpty
    ifTrue:  [recentFile writeText: ""] // create file
    ifFalse: [recentFile writeText: (recentPaths joinWith: "\n") + "\n"]
]

cleanRecent = [
  recentPaths <- recentPaths filter: [p -> File path: p, exists], toMutableList
  writeRecent do
]
cleanRecent do

resetGame = [
  pairs <-  pendingPairs
  allTranslations <- (pairs map: [it translation]) toSet toList
  queue <- shouldShuffle get
              ifTrue: [pairs shuffled toMutableList]
              ifFalse: [pairs toMutableList]

  initialTotal <- pairs count
  currentIdx <- 0
  wordsDone <- 0

  totalCorrect <- 0
  totalErrors <- 0
  hasErrorInCurrentWord <- false

  options <- {}
  optionsForWordDone <- -1
  disabledOptionIdx <- {}

  isCompleted <- false
  inGame <- true
]

loadPending = [
  path = pendingPath trim
  path isEmpty
    ifTrue: [statusMsg <- "Please provide a file path"]
    ifFalse: [
      file = File path: path
      file exists
        ifTrue: [
          parsed = List(WordPair) val: {}, toMut
          file readLines forEach: [line ->
            trimmed = line trim
            trimmed isEmpty
              ifFalse: [
                delimiter = (trimmed contains: "-")
                  ifTrue: ["-"]
                  ifFalse: [" "]

                parts = trimmed split: delimiter
                parts count > 1 ifTrue: [
                  original = parts first trim
                  translation = (parts drop: 1) joinWith: delimiter trim
                  original isNotEmpty && translation isNotEmpty
                    ifTrue: [parsed add: (WordPair :original :translation)]
                ]
              ]
          ]

          parsed isEmpty
            ifTrue: [statusMsg <- "No pairs found in the file"]
            ifFalse: [
              pendingPairs <- parsed toList
              statusMsg <- "Pairs loaded: " + (parsed count) toString
              recentPaths contains: path, ifFalse: [
                recentPaths add: path
                writeRecent do
              ]
              resetGame do
            ]
        ]
        ifFalse: [statusMsg <- "File not found"]
    ]
]

goNext = [
  hasCurrentPair ifTrue: [
    hasErrorInCurrentWord ifTrue: [
      queue add: currentPair
    ]

    queue removeAt: currentIdx

    wordsDone <- wordsDone + 1
    hasErrorInCurrentWord <- false
    disabledOptionIdx <- {}
    optionsForWordDone <- -1

    queue isEmpty
      ifTrue:  [isCompleted <- true]
      ifFalse: [currentIdx >= queue count ifTrue: [currentIdx <- 0]]
  ]
]

// main app
app = ImGui
        configure: [
          it setTitle: "niva imgui - selector"
          it setHeight: 600
          it setWidth: 600

        ]
        initImGui: [
          ImGui superInitImGuiFromConfig: it
          ImGui addFont: "/System/Library/Fonts/Supplemental/Arial.ttf" size: 22f
          ()
        ]
        process: [
          inGame ifFalse: [
            ImGui text: "Selector mode (4 options)"
            ImGui separator
            ImGui checkbox: "shuffle questions" value: shouldShuffle
            ImGui separator
            ImGui text: "Format: question - answer (or question answer)"
            ImGui inputText: "File path"
                  value: filePath
                  flag: ImGuiInputTextFlags.CallbackResize

            ImGui button: "Load and start", ifTrue: [
              pendingPath <- filePath get
              loadPending do
            ]

            recentPaths isNotEmpty ifTrue: [
              ImGui separator
              ImGui text: "Recent files"
              recentPaths forEach: [path ->
                shorterPath = path split: "/", last, toString
                ImGui button: shorterPath, ifTrue: [
                  pendingPath <- path
                  loadPending do
                ]
              ]
            ]

            statusMsg isNotEmpty ifTrue: [
              ImGui separator
              ImGui text: statusMsg
            ]
          ] ifTrue: [
            // keep currentIdx valid
            queue isNotEmpty ifTrue: [
              currentIdx >= queue count ifTrue: [currentIdx <- 0]
            ]

            queue isEmpty
              ifTrue: [hasCurrentPair <- false]
              ifFalse: [
                currentPair <- queue at: currentIdx
                hasCurrentPair <- true
              ]

            isCompleted
              ifTrue: [
                ImGui text: "Done"
                ImGui separator
                attempts = totalCorrect + totalErrors
                successPercent = attempts > 0
                  ifTrue: [((totalCorrect * 100) / attempts)]
                  ifFalse: [0]

                ImGui text: "Correct: " + (totalCorrect toString)
                ImGui text: "Errors: " + (totalErrors toString)
                ImGui text: "Success: " + (successPercent toString) + "%"

                ImGui separator
                ImGui button: "Restart", ifTrue: [
                  pendingPairs <- pairs
                  resetGame do
                ]
                ImGui sameLine
                ImGui button: "Menu", ifTrue: [
                  inGame <- false
                ]
              ]
              ifFalse: [
                hasCurrentPair ifTrue: [
                  // regenerate options for current word
                  optionsForWordDone != wordsDone ifTrue: [
                    optionsForWordDone <- wordsDone
                    disabledOptionIdx <- {}

                    correct = currentPair translation
                    mut incorrect = allTranslations filter: [it != correct]
                    incorrect <- incorrect shuffled

                    desiredOptions = 4
                    incorrectCount = desiredOptions - 1

                    incorrect count > incorrectCount ifTrue: [
                      incorrect <- incorrect viewFrom: 0 to: incorrectCount
                    ]

                    options <- ({correct} + incorrect) shuffled
                  ]

                  globalIndex = initialTotal - (queue count) + currentIdx + 1
                  ImGui text: "Question " + (globalIndex toString) + " of " + (initialTotal toString)
                  ImGui separator
                  ImGui text: currentPair original
                  ImGui separator

                  options forEachIndexed: [idx, option ->
                    isDisabled = disabledOptionIdx contains: idx

                    isDisabled
                      ifTrue: [
                        ImGui text: option + " (wrong)"]
                      ifFalse: [
                        ImGui button: option, ifTrue: [
                          (option == currentPair translation)
                            ifTrue: [
                              totalCorrect <- totalCorrect + 1
                              goNext do
                            ]
                            ifFalse: [
                              totalErrors <- totalErrors + 1
                              hasErrorInCurrentWord <- true
                              disabledOptionIdx <- disabledOptionIdx plus: idx
                            ]
                        ]
                      ]
                  ]

                  ImGui separator
                  ImGui button: "Menu",
                        ifTrue: [inGame <- false]
                ]
              ]
          ]
        ]

Application launch: app
